---
title: "quail_centrality_4_5percombo_analysis"
author: "Sanjay Prasher"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#load packages
```{r}

library(RMySQL)
library(dplyr)
library(ggplot2)
library(RColorBrewer)

#needed for foraging success chunk:
library(readr)
library(tidyr)
#library(dplyr)
library(stringr)


# Function to convert to matrix format using matrix.please function
matrix.please <- function(x) {
  m<-as.matrix(x[,-1])
  rownames(m)<-x[,1]
  m
}

```



#checking number of resets/food depletions across group sizes
##sql query
```{r}
#Enter the values for you database connection
dsn_database = "quail_centrality_4" # for example  "BLUDB"
dsn_hostname = "localhost" # for example  "mydbinstance.cz6pjylrdjko.us-east-1.rds.amazonaws.com"
dsn_port = 3306 # for example  3306 without quotation marks
dsn_uid = "root" # for example  "user1"
dsn_pwd = "hobsonSQL" # for example  "7dBZ3jWt9xN6$o0JiX!m"



conn = dbConnect(MySQL(), user=dsn_uid, password=dsn_pwd, host=dsn_hostname, port=dsn_port)
conn



use_command <- paste("USE", dsn_database, sep=" ");
dbSendQuery(conn, use_command);
query = "SELECT groupsize, 
                approachfood,
                resetnum,
                depletenum,
                ticks
          FROM quail_centrality_4_50
          WHERE mem IN (0, 50, 100, 150, 200) AND ticks=300"; #take only rows where ticks = 300 because those contain the final counts for each model run
rs = dbSendQuery(conn, query)
reset.data = dbFetch(rs, -1);
dbClearResult(rs)

head(reset.data)
nrow(reset.data)
str(reset.data)

```


##summarizing and plotting resets/depletions
```{r}
#summarize number of resets/food depletions per group size
resets.summary = reset.data %>% 
                  group_by(groupsize) %>%
                  summarize(mean.resets = mean(resetnum),
                            median.resets = median(resetnum),
                            mean.depletes = mean(depletenum),
                            median.depletes = median(depletenum))

#plot resets per parameter combo
ggplot(reset.data, aes(as.factor(groupsize), resetnum, color = approachfood)) +
    ggtitle("resets per group size") +
    labs(y = "resetnum", x = "groupsize") +
    geom_boxplot() +
    #theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave("./50percombo/resets_per_group_size.pdf", width=13, height=7)
#there are a higher number of resets for all group sizes when approachfood is true vs false
#the number of resets INCREASES with increasing group size, especially when approachfood is true
#variation in number of resets increases with increasing group size especially when approachfood is false



#plot depletions per parameter combo
ggplot(reset.data, aes(as.factor(groupsize), depletenum, color = approachfood)) +
    ggtitle("depletions per group size") +
    labs(y = "depletenum", x = "groupsize") +
    geom_boxplot() +
    #theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave("./50percombo/depletions_per_group_size.pdf", width=13, height=7)

#there are a higher number of depletions for all group sizes when approachfood is true vs false
#the number of depletions INCREASES with increasing group size, especially when approachfood is true
#variation in number of depletions increases with increasing group size when approachfood is false



#add depletions and resets together to get total number of times the food patch was reset during each simulation (both variables counted number of times food patch fell below resource-level 350, just in different phases)
reset.data$total.resets = reset.data$resetnum + reset.data$depletenum

resets_by_gsize = reset.data %>%
                  filter(groupsize %in% c(3, 6, 10, 15)) %>% 
                      ggplot(aes(as.factor(groupsize), 
                                                  total.resets, 
                                                  color = approachfood)) +
                      #ggtitle("Total number of food resets per group size") +
                      labs(y = "Number of food resets", 
                           x = "Group size",
                           color = "Scrounging") +
                      geom_boxplot() +
                      scale_color_manual(values = c("blue4", "red4"), 
                                         labels = c("Disabled", "Enabled")) +
                      theme_classic() +
                      theme(aspect.ratio=1,
                            legend.position = "bottom"
                            #text=element_text(size=15)
                            )

```



#calculating metrics of foraging success for agents other than the producer
```{r}

#library(readr)
#library(tidyr)
#library(dplyr)
#library(stringr)

group.sizes = c(3, 6, 10, 15)#, 20)

n.loops = max(group.sizes)
pb = txtProgressBar(min=0, max = n.loops, style=3)
start.time = Sys.time()
for(i in group.sizes) {
  
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
  
  gc()
  
  file.name = paste(file.path, "data_split.csv", sep = "/")
  
  f = function(x, pos) subset(x, select = -c(14:ncol(x)))#this will ignore all proximity columns before importing the data
  
  data = read_csv_chunked(file.name, callback = DataFrameCallback$new(f), col_types = cols()) #exclude proximity columns
  data = as.data.frame(data)
  
  #FOR EACH PARAMETER COMBO, I NEED:
  # 1. a count of how many time steps each agent or any agent other than the producer successfully foraged 
    #although the number of time steps might not change as much across parameter combos if more individuals are foraging in the same time step
  # 2. average energy level of foragers other than the producer at the end of the model (ticks = 300)
  
  
  #for count of time steps - group by run number, get count, then get average count for each parameter combo, which you can plot
  chr.to.find = as.character(1:(i-1)) #want to find all foragers except the producer (agent 0)
  chr.to.find = paste(chr.to.find, collapse = "|")
  
  
  for.success = data %>% 
    filter(rownames(data) %in% grep(chr.to.find, data$currentsuccforagers)) %>% #this gives all rows with time steps in which any forager other than the producer successfully foraged - the producer also foraged in many of these time steps
    group_by(run, 
             mem, 
             attention,
             preference, 
             approachfood) %>% 
    summarize(n.timesteps = n()) 
    
  # length(unique(for.success$run))
  # for.success is missing some run numbers because the ones where foragers other than the producer never foraged were removed when subsetting 
  # NEED TO FILL IN THE DATA FRAME TO INCLUDE ALL RUN NUMBERS
    
  data.to.add = data[!(data$run %in% for.success$run) & data$ticks == 0, 
                     names(data) %in% c("run", 
                                        "mem", 
                                         "attention",
                                         "preference", 
                                         "approachfood")] #subset of data containing one row from each run number that does not appear in for.success and columns for parameters that varied
  #nrow(data.to.add)
  data.to.add$n.timesteps = rep(0, nrow(data.to.add))
  
  for.success = rbind(for.success, data.to.add)
  #length(unique(for.success$run))
  rm(data.to.add)
  for.success = for.success[order(for.success$run),]
  
  #####
  # for average energy level of foragers, remove all rows where ticks is not 300; separate forager energy levels into separate columns; pivot longer so the energy levels are stacked in the same column; calculate average per run number or combo number
  data = data[data$ticks==300,]
  #nrow(data) #should be equal to number of combos
  data$energylist = gsub("[[]", "", data$energylist)
  data$energylist = gsub("[]]", "", data$energylist)
  energy.split = str_split_fixed(data$energylist, " ", i) #split data in energy.list column into i columns
  
  colnames(energy.split) = LETTERS[1:i] #set column names - unique letter for each agent (A = producer)
  
  data = cbind(data, energy.split)
  
  data = data %>% 
    pivot_longer(LETTERS[1:i], #pivot_longer is the same as melt in the reshape2 package
                 names_to = "agent", values_to = "energy")
  
  #now calculate average energy level for each run number
  data$energy = as.numeric(data$energy)
  data = data[data$agent != "A",] %>% #IGNORING ROWS FOR PRODUCER BECAUSE I AM INTERESTED IN THE AVERAGE ENERGY LEVEL OF THE OTHER FORAGERS
    group_by(run) %>%
    mutate(mean.run.energy = mean(energy), 
           med.run.energy = median(energy), 
           var.run.energy = var(energy)) #I checked that the mean values were accurate by using mutate() here instead of summarize
  
  data = data %>%
    group_by(combo.num) %>%
    mutate(mean.combo.energy = mean(energy), 
           med.combo.energy = median(energy), 
           var.combo.energy = var(energy))
  
  data = unique(data[,c("run", "combo.num", "mean.run.energy", "med.run.energy", "var.run.energy", "mean.combo.energy", "med.combo.energy", "var.combo.energy")])
  
  # add average energy level of foragers per run number to for.success data frame and write it to a csv file
  for.success = merge(for.success, data, by = "run")# I am merging to be safe, but the data should be in the correct order in both data frames, so I could just do for.success$mean.energy = q.data$mean.energy
  
  file.name = paste(file.path, "for_success.csv", sep = "/")
  write_csv(for.success, file.name)
  
  setTxtProgressBar(pb,i)#update progress bar
  
}#END OF LOOP
end.time = Sys.time()
run.time = end.time - start.time
run.time #all groups ran in two minutes for 5 runs per combo
```



#Checking how group size and approachfood impact average energy levels achieved by foragers at the end of each model run
```{r}
#rbind all the for_success files from different group sizes together
all.for.success = data.frame()
group.sizes = c(3, 6, 10, 15)#, 20)

for(i in group.sizes) {

  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
  
  
  file.name = paste(file.path, "for_success.csv", sep = "/")
  
  for.success = read_csv(file.name, col_types = cols())
  for.success = as.data.frame(for.success)
  
  for.success$groupsize = rep(i, nrow(for.success))
  
  all.for.success = rbind(all.for.success, for.success)
    
}


#plot mean energy levels by parameters
ggplot(all.for.success, aes(as.factor(groupsize), mean.run.energy, color = approachfood)) +
    ggtitle("mean energy per group size") +
    labs(y = "mean.run.energy", x = "groupsize") +
    geom_boxplot() +
    #theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

# THIS PLOT WILL BE IN THE SUPPLEMENTAL MATERIAL:
med.energy.by.gsize = ggplot(all.for.success, aes(as.factor(groupsize), 
                                                  med.run.energy, 
                                                  color = approachfood)) +
                      #ggtitle("median energy per group size") +
                      labs(y = "Median energy", 
                           x = "Group size",
                           color = "Scrounging") +
                      geom_boxplot() +
                      scale_color_manual(values = c("blue4", "red4"), 
                                         labels = c("Disabled", "Enabled")) +
                      theme_classic() +
                      theme(aspect.ratio=1
                            #text=element_text(size=15)
                            )

#ggsave("./50percombo/median_energy_per_group_size.pdf", width=13, height=7)


```




# CALCULATE PROXIMITY NETWORK METRICS AND DIFFERENCE IN PRODUCER STRENGTH BETWEEN PHASES
```{r}

#FUNCTION TO BE USED INSIDE FIRST BIG LOOP TO GET PRODUCER'S NETWORK METRICS FOR EACH PHASE
metrics.func = function(func.df) {
  prox.count = as.data.frame(func.df)
  for (j in 0:(i-1)) { #Loop to replace numbers in prox.ID column with letters 
    prox.count[prox.count$prox.ID == j,]$prox.ID = LETTERS[j+1]
  }
  #unique(prox.count$prox.ID) #check if the loop worked
  
  
  prox.metrics = data.frame(run = unique(prox.count$run), 
                            A.deg = 0, 
                            A.str = 0)
  
  
  for (j in unique(prox.count$run)) {
    #print(paste(i, j, sep = "-"))
    current.edge.list = prox.count[prox.count$run==j, names(prox.count) %in% c("prox.key", "prox.ID", "n")] #subset of prox.summ.pre giving the edge list for the current run
    #eg = igraph::graph_from_data_frame(current.edge.list, directed = FALSE) # this way was doubling the degrees
    
    current.matrix = current.edge.list %>% reshape2::dcast(prox.key ~ prox.ID, value.var = "n") 
    current.matrix = matrix.please(current.matrix)
    current.matrix = current.matrix[,!(colnames(current.matrix) %in% c("111", ""))]
    
    
    if (sum(!(LETTERS[1:i] %in% colnames(current.matrix))) > 0) { #if there is at least one individual missing from current.matrix
      
      missing.indiv = LETTERS[which(!(LETTERS[1:i] %in% colnames(current.matrix)))] # determine which individual(s) is/are missing
      
      for(k in missing.indiv) { #add a column to the matrix for each missing individual
        ind.vec = rep(0, nrow(current.matrix))
        current.matrix = cbind(current.matrix, ind.vec)
        colnames(current.matrix)[colnames(current.matrix) == "ind.vec"] = k
        
        #if (!(nrow(current.matrix) == i)){ # add a row for the missing individual if - I think some runs lost an individual when I removed rows with NAs in the prox.ID column (see setup script - the part where I make the prox_count_pre/for/post files)
        #  ind.vec = rep(0, ncol(current.matrix))
        #  current.matrix = rbind(current.matrix, ind.vec)
        #  rownames(current.matrix)[colnames(current.matrix) == "ind.vec"] = k
        #}
      }
    }
    
    current.matrix.half = sna::lower.tri.remove(current.matrix, remove.val=0)
    current.matrix.half[is.na(current.matrix.half)] = 0
    
    eg = igraph::graph_from_adjacency_matrix(current.matrix.half, mode="upper", weighted = TRUE, diag = FALSE)
#    igraph::E(eg)$norm.weight = igraph::E(eg)$weight/nrow(q.data[q.data$run == j,]) #make another igraph attribute that stores normalized weights (number of time steps in proximity divided by number of time steps within the phase - THIS IS ONLY NECESSARY IF YOU REMOVE TIME STEPS IN FORAGING PHASE BEFORE THE PRODUCER FIRST FORAGED)
    
    current.degree = igraph::degree(eg)
    current.strength = igraph::strength(eg) #don't need 'weights' argument if igraph object has edge weights attribute already
    
    current.metrics = cbind(current.degree,current.strength)
    
    prox.metrics[prox.metrics$run==j, 2:3] = current.metrics[row.names(current.metrics)=="A",] #save producer metrics in external data.frame
    
  }
  prox.metrics.out <<- prox.metrics #need this to save object inside function to external object
}





group.sizes = c(3, 6, 10, 15)#, 20)

n.loops = max(group.sizes)
pb = txtProgressBar(min=0, max = n.loops, style=3)
start.time = Sys.time()

for(i in group.sizes){ #Proximity network
  
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
 
  file.name = paste(file.path, "prox_count_pre50.csv", sep = "/")
  prox.count.pre = read_csv(file.name, col_types = cols()) #edge list for PRE-foraging period - contains data from all runs
  prox.count.pre = as.data.frame(prox.count.pre)
  
  file.name = paste(file.path, "prox_count_for50.csv", sep = "/")
  prox.count.for = read_csv(file.name, col_types = cols()) #edge list for foraging period - contains data from all runs
  prox.count.for = as.data.frame(prox.count.for)
  
  file.name = paste(file.path, "prox_count_post50.csv", sep = "/")
  prox.count.post = read_csv(file.name, col_types = cols()) #edge list for POST-foraging period - contains data from all runs
  prox.count.post = as.data.frame(prox.count.post)
  
  
  
  file.name2 = paste(file.path, "data_pre50.csv", sep = "/")
  data = read_csv(file.name2, col_types = cols())
  data = as.data.frame(data)
  prox.metrics.out = data.frame()
  metrics.func(prox.count.pre) # see function defined at beginning of script
  file.out = paste(file.path, "prox_metrics_pre.csv", sep = "/")
  write_csv(prox.metrics.out, file.out)
  rm(data)
  gc()
  
  
  file.name2 = paste(file.path, "data_forage50.csv", sep = "/")
  data = read.csv(file.name2, header=T)
  data = as.data.frame(data)
  prox.metrics.out = data.frame()
  metrics.func(prox.count.for) # see function defined at beginning of script
  file.out = paste(file.path, "prox_metrics_for.csv", sep = "/")
  write_csv(prox.metrics.out, file.out)
  rm(data)
  gc()
  
  
  file.name2 = paste(file.path, "data_post50.csv", sep = "/")
  data = read_csv(file.name2, col_types = cols())
  data = as.data.frame(data)
  prox.metrics.out = data.frame()
  metrics.func(prox.count.post) # see function defined at beginning of script
  file.out = paste(file.path, "prox_metrics_post.csv", sep = "/")
  write_csv(prox.metrics.out, file.out)
  rm(data)
  gc()
  
  
  setTxtProgressBar(pb,i)#update progress bar
  
} # END OF BIG LOOP

end.time = Sys.time()
run.time = end.time - start.time
run.time 


rm(pb, prox.count.pre, prox.count.for, prox.count.post, prox.metrics.out)


n.loops = max(group.sizes)
pb = txtProgressBar(min=0, max = n.loops, style=3)
start.time = Sys.time()

for(i in group.sizes){ #calculating differences in proximity network metrics between phases
  
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
 
  gc()
  
  #to.read = list.files()[10] # 10th file in the working directory should be q_data_split for that group size (make sure files written in this loop are not already in the working directory)
  file.name = paste(file.path, "data_split.csv", sep = "/")
  data.split = read_csv(file.name, col_types = cols())
  data.split = as.data.frame(data.split[, -c(14:ncol(data.split))]) #exclude proximity columns (goes up to 393 for group size of 20)
  
  file.name = paste(file.path, "prox_metrics_pre.csv", sep = "/")
  prox.metrics.pre = read_csv(file.name, col_types = cols())
  prox.metrics.pre = as.data.frame(prox.metrics.pre)
  
  file.name = paste(file.path, "prox_metrics_for.csv", sep = "/")
  prox.metrics.for = read_csv(file.name, col_types = cols())
  prox.metrics.for = as.data.frame(prox.metrics.for)
  
  file.name = paste(file.path, "prox_metrics_post.csv", sep = "/")
  prox.metrics.post = read_csv(file.name, col_types = cols())
  prox.metrics.post = as.data.frame(prox.metrics.post)

  
  # want to see if mem, att, pref have an effect on producer's centrality using network metrics from pre-forage phase as a baseline
  #####calculate differences between producer's network metrics between phases for each combo of mem/att/pref#####
  uniq.ds = unique(data.split[,c("run", "groupsize", "mem", "attention", "preference", "approachfood", "combo.num")]) #data frame containing unique combinations of model parameters 
  
  
  prox.forXpre = data.frame(run = uniq.ds$run) # data frame for differences between foraging and pre-foraging phases
  prox.forXpre$forXpre.deg = prox.metrics.for$A.deg - prox.metrics.pre$A.deg # differences in degree
  prox.forXpre$forXpre.str = prox.metrics.for$A.str - prox.metrics.pre$A.str # differences in strength
  
  prox.forXpre = merge(prox.forXpre, uniq.ds, by = "run") #adds parameter values to data frame containing differences in producer network metrics
  #nrow(prox.forXpre)
  #View(prox.forXpre)
  file.out = paste(file.path, "prox_forxpre.csv", sep = "/")
  write_csv(prox.forXpre, file.out)
  
  
  prox.postXfor = data.frame(run = uniq.ds$run) # data frame for differences between post-foraging and foraging phases
  prox.postXfor$postXfor.deg = prox.metrics.post$A.deg - prox.metrics.for$A.deg # differences in degree
  prox.postXfor$postXfor.str = prox.metrics.post$A.str - prox.metrics.for$A.str # differences in strength
  
  prox.postXfor = merge(prox.postXfor, uniq.ds, by = "run") #adds parameter values to data frame with differences in producer network metrics
  file.out = paste(file.path, "prox_postxfor.csv", sep = "/")
  write_csv(prox.postXfor, file.out)
  
  
  prox.postXpre = data.frame(run = uniq.ds$run) # data frame for differences between post-foraging and pre-foraging phases
  prox.postXpre$postXpre.deg = prox.metrics.post$A.deg - prox.metrics.pre$A.deg # differences in degree
  prox.postXpre$postXpre.str = prox.metrics.post$A.str - prox.metrics.pre$A.str # differences in strength
  
  prox.postXpre = merge(prox.postXpre, uniq.ds, by = "run") #adds parameter values to data frame with differences in producer network metrics
  file.out = paste(file.path, "prox_postxpre.csv", sep = "/")
  write_csv(prox.postXpre, file.out)
  
  setTxtProgressBar(pb,i)#update progress bar
}

end.time = Sys.time()
run.time = end.time - start.time
run.time


```



# GETTING RANGES OF VARIABLES ACROSS GROUP SIZES BEFORE PLOTTING
```{r}

group.sizes = c(3, 6, 10, 15)#, 20)

str.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR MEDIAN STRENGTH ACROSS GROUP SIZES
mean.energy.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR MEAN ENERGY LEVEL OF FORAGERS ACROSS GROUP SIZES
median.energy.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR MEDIAN ENERGY LEVEL OF FORAGERS ACROSS GROUP SIZES
var.energy.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR VARIANCE IN ENERGY LEVEL OF FORAGERS ACROSS GROUP SIZES

med.ticks.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR MEDIAN NUMBER OF TICKS DURING WHICH FORAGERS ATE
mean.ticks.range = vector() #VECTOR TO HOLD MIN AND MAX VALUES FOR MEAN NUMBER OF TICKS DURING WHICH FORAGERS ATE

for(i in group.sizes){ #GETTING RANGE OF MEDIAN STRENGTH IN PROXIMITY NETWORK, MEAN ENERGY, AND VARIANCE ENERGY TO USE FOR THE COLOR SCALE OF PLOTS (USE THIS IF YOU WANT THE SAME SCALE ACROSS GROUP SIZES)
  
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
 
  file.name = paste(file.path, "prox_forxpre.csv", sep = "/")
  prox.forXpre = read_csv(file.name, col_types = cols()) # including the 'col_types = cols()' argument suppresses the unnecessary column specification messages from read_csv
  prox.forXpre = as.data.frame(prox.forXpre)

  file.name = paste(file.path, "prox_postxfor.csv", sep = "/")
  prox.postXfor = read_csv(file.name, col_types = cols())
  prox.postXfor = as.data.frame(prox.postXfor)

  file.name = paste(file.path, "prox_postxpre.csv", sep = "/")
  prox.postXpre = read_csv(file.name, col_types = cols())
  prox.postXpre = as.data.frame(prox.postXpre)

  
  #summarize data (median) for each variable combination before making heat maps
  #check distribution of network metric differences for each variable combination to see how to proceed with summarizing the data
  #If the data are skewed it is better to summarize it using the median
#  par(mfrow=c(2,2))
  
#  hist(prox.forXpre[prox.forXpre$combo.num == 1001,]$forXpre.deg)
#  hist(prox.forXpre[prox.forXpre$combo.num == 1001,]$forXpre.str)#, breaks = seq(0, 500, 20))
#  
#  hist(prox.postXpre[prox.postXpre$combo.num == 1001,]$postXpre.deg)
#  hist(prox.postXpre[prox.postXpre$combo.num == 1001,]$postXpre.str)#, breaks = seq(0, 500, 20))
  
  
  #finding medians of network metric differences between foraging and pre-foraging phases for each combo:
  pfxp.med = prox.forXpre %>% 
    group_by(combo.num) %>% 
    summarize(n = n(), 
              med.deg = median(forXpre.deg), 
              med.str = median(forXpre.str))
  
  #finding medians of network metric differences between post- and foraging phases for each combo:
  ppxf.med = prox.postXfor %>% 
    group_by(combo.num) %>% 
    summarize(n = n(), 
              med.deg = median(postXfor.deg), 
              med.str = median(postXfor.str))
  
  #finding medians of network metric differences between post- and pre-foraging phases for each combo:
  ppxp.med = prox.postXpre %>% 
    group_by(combo.num) %>% 
    summarize(n = n(), 
              med.deg = median(postXpre.deg), 
              med.str = median(postXpre.str))
  
  #add ranges of median strengths to the empty vector
  str.range = append(str.range, 
                     c(range(pfxp.med$med.str), range(ppxf.med$med.str), range(ppxp.med$med.str)), 
                     after = length(str.range))
  
  
  
  ###################################################################
  file.name = paste(file.path, "for_success.csv", sep = "/")
  for.success = read_csv(file.name, col_types = cols())
  for.success = as.data.frame(for.success)

  for.success = for.success
  
  
  mean.energy.range = append(mean.energy.range, 
                             range(for.success$mean.combo.energy), 
                             after = length(mean.energy.range))
  median.energy.range = append(median.energy.range, 
                               range(for.success$med.combo.energy), 
                               after = length(median.energy.range))
  var.energy.range = append(var.energy.range, 
                            range(for.success$var.combo.energy), 
                            after = length(var.energy.range))
  
  
  ticks.per.combo = for.success %>% 
    group_by(combo.num) %>% 
    mutate(n=n(), 
           med.ticks = median(n.timesteps), 
           mean.ticks = mean(n.timesteps))
  
  med.ticks.range = append(med.ticks.range, 
                           range(ticks.per.combo$med.ticks), 
                           after = length(med.ticks.range))
  mean.ticks.range = append(mean.ticks.range, 
                            range(ticks.per.combo$mean.ticks), 
                            after = length(mean.ticks.range))
  
  gc()
} #END OF LOOP

rm(pfxp.med, ppxf.med, ppxp.med, prox.forXpre, prox.postXfor, prox.postXpre)


```



# PLOTTING DIFFERENCE IN PRODUCER'S STRENGTH BETWEEN PHASES AND AVG ENERGY LEVELS ACROSS PARAMETER COMBOS
NOTE: FOR EACH GROUP SIZE, str.range CONTAINS 6 VALUES - A MIN/MAX FOR EACH PAIR OF PHASES
e.g., str.range[1:2] is the min and max difference in strength between foraging and pre-foraging
      str.range[3:4] is the min and max difference in strength between post-foraging and foraging
```{r}

pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')), space='Lab')

#PDFs become corrupted when I use this loop, but not when I run all the code after changing the value of i manually

#for(i in group.sizes){ #GETTING RANGE OF MEDIAN STRENGTH IN PROXIMITY NETWORK TO USE FOR THE COLOR SCALE OF PLOTS
  
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
    str.range1 = str.range[1:6] #take subset of str.range only if you want to have a different scale for each group size 
#    str.range1 = str.range # if you want to have the same scale for all group sizes, then use this line instead
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
    str.range1 = str.range[7:12]
#    str.range1 = str.range # if you want to have the same scale for all group sizes, then use this line instead
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
    str.range1 = str.range[13:18]
#    str.range1 = str.range # if you want to have the same scale for all group sizes, then use this line instead
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
    str.range1 = str.range[19:24]
#    str.range1 = str.range # if you want to have the same scale for all group sizes, then use this line instead
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
    str.range1 = str.range[25:30]
#    str.range1 = str.range # if you want to have the same scale for all group sizes, then use this line instead
    
  }
  
  
  dir.create(paste(file.path, "plots", sep = "/")) #create a new folder in the current working directory that will hold all the plots from this loop
  
  file.name = paste(file.path, "prox_forxpre.csv", sep = "/")
  prox.forXpre = read_csv(file.name, col_types = cols())
  prox.forXpre = as.data.frame(prox.forXpre)
  
  file.name = paste(file.path, "prox_postxfor.csv", sep = "/")
  prox.postXfor = read_csv(file.name, col_types = cols())
  prox.postXfor = as.data.frame(prox.postXfor)

  file.name = paste(file.path, "prox_postxpre.csv", sep = "/")
  prox.postXpre = read_csv(file.name, col_types = cols())
  prox.postXpre = as.data.frame(prox.postXpre)

  
  
  
  ############################################################
  ############################################################
  #finding medians of network metric differences between foraging and pre-foraging phases for each combo:
  pfxp.med = prox.forXpre %>% 
    group_by(combo.num) %>% 
    summarize(n=n(), 
              med.deg = median(forXpre.deg), 
              med.str = median(forXpre.str))
  
  pfxp.med = merge(pfxp.med, unique(prox.forXpre[,c("groupsize", "mem", "attention", "preference", "approachfood", "combo.num")]), by = "combo.num")
  rm(prox.forXpre)
  
  #plot of median difference in producer degree between foraging and pre-foraging phases
  #ggplot(pfxp.med, aes(as.factor(preference), as.factor(attention), fill = med.deg)) +
  #  ggtitle("Difference in producer's proximity degree between foraging and pre-foraging phases") +
  #  labs(y = "Attention", x = "Preference", fill = "Median Difference in Degree") +
  #  facet_grid(rows=vars(memory)) +
  #  geom_tile() +
  #  scale_fill_gradient(low="white", high="red") +
  #  theme_minimal()
  
  
#  pdf("./plots/StrengthForxPre_scaled.pdf", width=7, height=13)
  
  #plot of median difference in producer strength between foraging and pre-foraging phases 
  ggplot(pfxp.med, aes(as.factor(preference), as.factor(attention), fill = med.str)) +
    ggtitle(paste("Difference in producer's proximity strength between foraging and pre-foraging phases",
            "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median Difference in Strength") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(str.range1), 0, max(str.range1)), limits=c(min(str.range1), max(str.range1))) +
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
  
   ggsave(paste(file.path, "/plots/StrengthForxPre.pdf", sep = ""), width=13, height=7)
  
  #rm(pfxp.med) #not removing this, because I will use it for foraging success plots as well
  
  ############################################################
  ############################################################
  #finding medians of network metric differences between post- and foraging phases for each combo:
  ppxf.med = prox.postXfor %>% 
    group_by(combo.num) %>% 
    summarize(n=n(), 
              med.deg = median(postXfor.deg), 
              med.str = median(postXfor.str))
  
  ppxf.med = merge(ppxf.med, unique(prox.postXfor[,c("groupsize", "mem", "attention", "preference", "approachfood", "combo.num")]), by = "combo.num")
  rm(prox.postXfor)
  
  
#  pdf("./plots/StrengthPostxFor_scaled.pdf", width=7, height=13)
  
  #plot of median difference in producer strength between post- and foraging phases 
  ggplot(ppxf.med, aes(as.factor(preference), as.factor(attention), fill = med.str)) +
    ggtitle(paste("Difference in producer's proximity strength between post- and foraging phases", 
            "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median Difference in Strength") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(str.range1), 0, max(str.range1)), limits=c(min(str.range1), max(str.range1))) +
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
   ggsave(paste(file.path,"/plots/StrengthPostxFor.pdf", sep = ""), width=13, height=7)
  
  rm(ppxf.med)
  
  ############################################################
  ############################################################
  #finding medians of network metric differences between post- and pre-foraging phases for each combo:
  ppxp.med = prox.postXpre %>% 
    group_by(combo.num) %>% 
    summarize(n=n(), 
              med.deg=median(postXpre.deg), 
              med.str = median(postXpre.str))
  
  ppxp.med = merge(ppxp.med, unique(prox.postXpre[,c("groupsize", "mem", "attention", "preference", "approachfood", "combo.num")]), by = "combo.num")
  rm(prox.postXpre)
  
#  pdf("./plots/StrengthPostxPre_scaled.pdf", width=7, height=13)
  
  #plot of median difference in producer strength between post and pre-foraging phases WHEN APPROACH.FOOD SWITCH WAS OFF
  ggplot(ppxp.med, aes(as.factor(preference), as.factor(attention), fill = med.str)) +
    ggtitle(paste("Difference in producer's proximity strength between post- and pre-foraging phases",
                  "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median Difference in Strength") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(str.range1), 0, max(str.range1)), limits=c(min(str.range1), max(str.range1))) +
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
   ggsave(paste(file.path, "/plots/StrengthPostxPre.pdf", sep = ""), width=13, height=7)
  
  rm(ppxp.med)
  
  
  ############################################################
  ############################################################
  #PLOTS FOR FORAGING SUCCESS OF NON-PRODUCERS
  file.name = paste(file.path, "for_success.csv", sep = "/")
  for.success = read_csv(file.name, col_types = cols())
  for.success = as.data.frame(for.success)
#  for.success = as.data.frame(for.success[for.success$approach.food == FALSE,-1]) # use this line if you only want plots for when approach food switch was off
  
  
  #plot mean energy level per combo like you did for differences in producer strength
#  pdf("./plots/meanenergy.pdf", width=7, height=13)
  
  #plot of mean energy level 
  ggplot(for.success, aes(as.factor(preference), as.factor(attention), fill = mean.combo.energy)) +
    ggtitle(paste("Mean energy of foragers",
                  "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Mean energy level") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(for.success$mean.combo.energy), 0, max(for.success$mean.combo.energy)), limits=c(min(for.success$mean.combo.energy), max(for.success$mean.combo.energy))) +
#    scale_fill_gradientn(colours = pal(100), breaks=c(min(mean.energy.range), 0, max(mean.energy.range)), limits=c(min(mean.energy.range), max(mean.energy.range))) + # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
   ggsave(paste(file.path, "/plots/meanenergy.pdf", sep = ""), width=13, height=7)
  
  
  #plot median energy level per combo
#  pdf("./plots/medianenergy.pdf", width=7, height=13)
  
  #plot of median energy level
  ggplot(for.success, aes(as.factor(preference), as.factor(attention), fill = med.combo.energy)) +
    ggtitle(paste("Median energy of foragers", 
                  "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median energy level") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(for.success$med.combo.energy), 0, max(for.success$med.combo.energy)), limits=c(min(for.success$med.combo.energy), max(for.success$med.combo.energy))) +
#    scale_fill_gradientn(colours = pal(100), breaks=c(min(median.energy.range), 0, max(median.energy.range)), limits=c(min(median.energy.range), max(median.energy.range))) + # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
  ggsave(paste(file.path, "/plots/medianenergy.pdf", sep = ""), width=13, height=7)
  
  
  #plot variance in energy level per combo the same way
#  pdf("./plots/varenergy.pdf", width=7, height=13)
  
  #plot of variance in energy levels
  ggplot(for.success, aes(as.factor(preference), as.factor(attention), fill = var.combo.energy)) +
    ggtitle(paste("Variance in energy of foragers", 
                  "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Variance in energy level") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(for.success$var.combo.energy), 0, max(for.success$var.combo.energy)), limits=c(min(for.success$var.combo.energy), max(for.success$var.combo.energy))) +
#    scale_fill_gradientn(colours = pal(100), breaks=c(min(var.energy.range), 0, max(var.energy.range)), limits=c(min(var.energy.range), max(var.energy.range))) + # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
   ggsave(paste(file.path, "/plots/varenergy.pdf", sep = ""), width=13, height=7)
  
  
  #calculate mean or median number of time steps that foragers ate for each combo number and plot in the same way
  #hist(for.success$n.timesteps)
  ticks.per.combo = for.success %>% 
    group_by(combo.num) %>% 
    mutate(n=n(), med.ticks=median(n.timesteps), mean.ticks = mean(n.timesteps))
  
  #RESCALE MEDIAN AND MEAN TICKS TO GET VALUES BETWEEN 0-1 (THIS DOES NOT CHANGE THE PLOTS AT ALL)
  #ticks.per.combo$med.ticks = rescale(ticks.per.combo$med.ticks)
  #ticks.per.combo$mean.ticks = rescale(ticks.per.combo$mean.ticks)
    
  #calculating where middle of legend should be if the scale is different across group sizes
  mid.break.mean = min(ticks.per.combo$mean.ticks) + ((max(ticks.per.combo$mean.ticks) - min(ticks.per.combo$mean.ticks))/2) #this should just be 0.5 if rescaling mean.ticks
  mid.break.median = min(ticks.per.combo$med.ticks) + ((max(ticks.per.combo$med.ticks) - min(ticks.per.combo$med.ticks))/2) #this should just be 0.5 if rescaling med.ticks
  
  
  #calculating where middle of legend should be if the scale is the same across group sizes
#  mid.break.mean = min(mean.ticks.range) + ((max(mean.ticks.range) - min(mean.ticks.range))/2)
#  mid.break.median = min(med.ticks.range) + ((max(med.ticks.range) - min(med.ticks.range))/2)
  
  
#  pdf("./plots/meanticksforaged.pdf", width=7, height=13)
  
  #plot of mean number of time steps foragers ate 
  ggplot(ticks.per.combo, aes(as.factor(preference), as.factor(attention), fill = mean.ticks)) +
    ggtitle(paste("Mean # time steps foragers ate", 
                  "group size =", i, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Mean # time steps") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), breaks=c(min(ticks.per.combo$mean.ticks), mid.break.mean, max(ticks.per.combo$mean.ticks)), limits=c(min(ticks.per.combo$mean.ticks), max(ticks.per.combo$mean.ticks))) +
#    scale_fill_gradientn(colours = pal(100), breaks=c(min(mean.ticks.range), mid.break.mean, max(mean.ticks.range)), limits=c(min(mean.ticks.range), max(mean.ticks.range))) + # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
  ggsave(paste(file.path, "/plots/meanticksforaged.pdf", sep = ""), width=13, height=7)
  
  
  #plot foraging success metrics by median change in producer's strength between foraging and pre-foraging phases
  
  ticks.mrg = merge(unique(ticks.per.combo[,!names(ticks.per.combo) %in% c("run", "n.timesteps", "mean.run.energy", "med.run.energy", "var.run.energy")]), 
                    pfxp.med[,names(pfxp.med) %in% c("combo.num", "med.str")], 
                    by = "combo.num")
  
#  pdf("./plots/meanticksforagedXstrength.pdf", width=7, height=13)
  
  #plot of mean number of time steps foragers ate by change in producer's strength
  ggplot(ticks.mrg, aes(med.str, mean.ticks, color = as.factor(preference), shape = as.factor(attention))) + #include 'color = approach.food' after mean.ticks in this line if plotting a different color for each level of approach.food
    ggtitle(paste("Mean # time steps foragers ate by change in producer's strength",
                  "group size =", i, sep = " ")) +
    labs(y = "Mean # time steps foraged", x = "Median change in producer's strength") +
    scale_x_continuous( limits = c(-1, max(str.range1))) + 
    scale_y_continuous( breaks = seq(0, ceiling(max(ticks.mrg$mean.ticks)), by = 2)) + # USE THIS LINE FOR DIFFERENT SCALES ACROSS GROUP SIZES
#    scale_y_continuous( limits = c(floor(min(mean.ticks.range)), ceiling(max(mean.ticks.range))) ) +  # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    facet_grid(rows=vars(approachfood), cols=vars(mem)) + #add 'cols = vars(approach.food)' if you want a different column for each level of approach.food
    geom_point() +
    theme_minimal() +
    theme(axis.line.x.bottom=element_line(linewidth = 1), axis.line.y.left=element_line(linewidth = 1), aspect.ratio=1, text=element_text(size=15))
    
#  dev.off()
  ggsave(paste(file.path, "/plots/meanticksforagedXstrength.pdf", sep = ""), width=14, height=10)
  
  
#  pdf("./plots/meanenergyXstrength.pdf", width=7, height=13)
  
  #plot of mean energy level of foragers by change in producer's strength
  ggplot(ticks.mrg, aes(med.str, mean.combo.energy, color = as.factor(preference), shape = as.factor(attention))) + #include 'color = approach.food' after mean.combo.energy in this line if plotting a different color for each level of approachfood
    ggtitle(paste("Mean energy level of foragers by change in producer's strength",
                  "group size =", i, sep = " ")) +
    labs(y = "Mean energy level of foragers", x = "Median change in producer's strength") +
    scale_x_continuous( limits = c(-1, max(str.range1))) + 
    scale_y_continuous( breaks = seq(floor(min(ticks.mrg$mean.combo.energy)), ceiling(max(ticks.mrg$mean.combo.energy)), by = 5)) + # USE THIS LINE FOR DIFFERENT SCALES ACROSS GROUP SIZES
#    scale_y_continuous( limits = c(floor(min(mean.energy.range)), ceiling(max(mean.energy.range))) ) + # USE THIS LINE FOR SAME SCALE ACROSS GROUP SIZES
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_point() +
    theme_minimal() +
    theme(axis.line.x.bottom=element_line(linewidth = 1), axis.line.y.left=element_line(linewidth = 1), aspect.ratio=1, text=element_text(size=15))
  
#  dev.off()
  ggsave(paste(file.path, "/plots/meanenergyXstrength.pdf", sep = ""), width=14, height=10)
  
  gc()
  
#} # END OF PLOTTING LOOP


```



# MEMORY QUESTIONS
##query to get parameters of interest and fsslist
```{r}

#Enter the values for you database connection
dsn_database = "quail_centrality_4" # for example  "BLUDB"
dsn_hostname = "localhost" # for example  "mydbinstance.cz6pjylrdjko.us-east-1.rds.amazonaws.com"
dsn_port = 3306 # for example  3306 without quotation marks
dsn_uid = "root" # for example  "user1"
dsn_pwd = "hobsonSQL" # for example  "7dBZ3jWt9xN6$o0JiX!m"


conn = dbConnect(MySQL(), user=dsn_uid, password=dsn_pwd, host=dsn_hostname, port=dsn_port)
conn


use_command <- paste("USE", dsn_database, sep=" ");
dbSendQuery(conn, use_command);
query = "SELECT run,
                groupsize,
                mem, 
                attention, 
                preference, 
                approachfood,
                fsslist, ##fsslist object from netlogo stores each individual's first successful forager seen
                ticks
          FROM quail_centrality_4_50 WHERE mem IN (0, 50, 100, 150, 200) AND groupsize IN (3, 6, 10, 15)";
rs = dbSendQuery(conn, query)
fss.data = dbFetch(rs, -1);
dbClearResult(rs)

```



##At which parameter combos are agents remembering a non-producer more often than they remember the producer?
```{r}
###split fsslist contents and compile them into a single vector for each run----

#order fss.data by parameter combination and remove rows associated with ticks ==0 (the starting tick in each run)
fss.data = fss.data %>% 
          filter(!(fss.data$ticks == 0)) %>%
          arrange(run, ticks)

#remove square brackets from the column
fss.data$fsslist = gsub("[[]", "", fss.data$fsslist) 
fss.data$fsslist = gsub("[]]", "", fss.data$fsslist)


#split the values at the space to get a list of vectors 
#(each item in the list corresponds to each row in fss.data)
fsslist.split = str_split(fss.data$fsslist, " ")

#remove the producer's firstsfseen (i.e., the first value in each vector)
fsslist.split2 = lapply(fsslist.split, function(x) x[-1])

#compile the vectors within each run into one big vector
#each combo has 301ticks*50runs=15050 rows
combine.vectors = function(my_list, grp.size){ # define a function that will do the concatenation
  
  num.groups = length(my_list) %/% grp.size #grp.size is the number of rows per run (301)
  
  combined.list = lapply(seq(1, length(my_list), by = grp.size), 
                         function(i) {do.call(c, my_list[i:(i + grp.size - 1)])}) # for fsslist.split2 item 1, 302, 603, etc., lapply will run the do.call function, which concatenates the vectors from items 1:301, 302:602, and so on
  
  return(combined.list)
}

#run the function on fsslist.split2 to get one item in the list per phase
fsslist.split.concat = combine.vectors(my_list = fsslist.split2, 
                                       grp.size = 100) #this new list should have 3x the number of items as there are runs in fss.data

length(fsslist.split.concat) == 3*length(unique(fss.data$run)) #check - this should be TRUE

fsslist.split.concat = suppressWarnings(lapply(fsslist.split.concat, as.integer))


#run the function on fsslist.split2 to get one item in the list per run
fsslist.split.concat.total = combine.vectors(my_list = fsslist.split2, 
                                       grp.size = 300) #this new list should have the same number of items as there are runs in fss.data

length(fsslist.split.concat.total) == length(unique(fss.data$run)) #check - this should be TRUE

fsslist.split.concat.total = suppressWarnings(lapply(fsslist.split.concat.total, as.integer))


###calculate proportion of each run's vector contents that are the producer's ID----
runs.props = data.frame(run = unique(fss.data$run),
                        props.total = rep(NA, length(unique(fss.data$run)))
                        )#data frame that will hold runs with their corresponding proportions

props.vector = vector()#vector to store proportions for each run (all 3 phases)
props.vector.withNAs = vector() #vector to store proportions when including counts of NAs as first-sf-seen

props.pre = vector() #vector to store proportions for pre-foraging phase in each run
props.for = vector() #vector to store proportions for foraging phase in each run
props.post = vector() #vector to store proportions for post-foraging phase in each run

pre.nums = seq(from = 1, to = length(fsslist.split.concat), by = 3)#items in fsslist.split.concat corresponding to pre-foraging phases
for.nums = seq(from = 2, to = length(fsslist.split.concat), by = 3)#items in fsslist.split.concat corresponding to foraging phases
post.nums = seq(from = 3, to = length(fsslist.split.concat), by = 3)#items in fsslist.split.concat corresponding to post-foraging phases


for(i in 1:length(fsslist.split.concat)) {#for each PHASE's vector calculate proportion of IDs in memory that were the producer
  
  item.i = fsslist.split.concat[[i]]#item i in the concatenated list
  
  if(i %in% pre.nums) {
    
    total.length.pre = sum(!is.na(item.i)) # total number of non-NAs (all IDs remembered during this phase)
  
    producer.count.pre = sum(item.i %in% 0)# count total number of zeros (producer saved as fss)
    
    prop.producer.pre = producer.count.pre/total.length.pre #calculate proportion
    props.pre = append(props.pre, prop.producer.pre) #append proportion to the external vector
    
  } else if(i %in% for.nums) {
    
    total.length.for = sum(!is.na(item.i)) # total number of non-NAs (all IDs remembered during this phase)
  
    producer.count.for = sum(item.i %in% 0)# count total number of zeros (producer saved as fss)
    
    prop.producer.for = producer.count.for/total.length.for #calculate proportion
    props.for = append(props.for, prop.producer.for) #append proportion to the external vector
    
  } else if(i %in% post.nums) {
    
    total.length.post = sum(!is.na(item.i)) # total number of non-NAs (all IDs remembered during this phase)
  
    producer.count.post = sum(item.i %in% 0)# count total number of zeros (producer saved as fss)
    
    prop.producer.post = producer.count.post/total.length.post #calculate proportion
    props.post = append(props.post, prop.producer.post) #append proportion to the external vector
    
  }
  
}
runs.props$props.pre = props.pre
runs.props$props.for = props.for
runs.props$props.post = props.post
  

for(i in 1:length(fsslist.split.concat.total)) {#for each RUN's vector calculate proportion of IDs in memory that were the producer
  
  item.i = fsslist.split.concat.total[[i]]#item i in the concatenated list
  
   
  total.length = sum(!is.na(item.i)) # total number of non-NAs (all IDs that were remembered during this run)
  total.length.withNAs = length(item.i) # total number of first-sf-seen values, including NAs
  
  producer.count = sum(item.i %in% 0)# count total number of zeros (producer saved as fss)
    
  prop.producer = producer.count/total.length #calculate proportion
  props.vector = append(props.vector, prop.producer) #append proportion to the external vector
  
  prop.producer.withNAs = producer.count/total.length.withNAs #calculate proportion
  props.vector.withNAs = append(props.vector.withNAs, prop.producer.withNAs) #append proportion to the external vector
  
}

runs.props$props.total = props.vector#add vector to dataframe that contains run IDs
#tail(runs.props)

runs.props$props.withNAs = props.vector.withNAs



#put all data in one data frame so you can summarize
uniq.fss.data = unique(fss.data[,names(fss.data) %in% c("run", 
                                                        "groupsize", 
                                                        "mem", 
                                                        "attention", 
                                                        "preference", 
                                                        "approachfood")])

uniq.fss.data = merge(uniq.fss.data, runs.props, by.all = "run")
#head(uniq.fss.data)



write.csv(uniq.fss.data, "./50percombo/proportion_fss_producer.csv")
```



###plotting proportion of times producer was remembered as the successful forager by other
```{r}

prop.data = read.csv("./50percombo/proportion_fss_producer.csv")

# calculate mean/median/variance of proportions for each parameter combo
prop.data = prop.data %>%
    group_by(groupsize,
             mem, 
             attention, 
             preference, 
             approachfood) %>%
    summarize(mean.prop.total = mean(props.total), 
               med.prop.total = median(props.total), 
               var.prop.total = var(props.total),
               mean.prop.withNAs = mean(props.withNAs),
               med.prop.withNAs = median(props.withNAs), 
               var.prop.withNAs = var(props.withNAs),
               mean.prop.pre = mean(props.pre),
               med.prop.pre = median(props.pre), 
               var.prop.pre = var(props.pre),
               mean.prop.for = mean(props.for),
               med.prop.for = median(props.for), 
               var.prop.for = var(props.for),
               mean.prop.post = mean(props.post),
               med.prop.post = median(props.post), 
               var.prop.post = var(props.post))

### plot mean/median/variance of proportion for each parameter combo using a heat map----
pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')), space='Lab')
redpal <- colorRampPalette(rev(brewer.pal(11, 'Reds')), space='Lab')
#group.sizes = c(3, 6, 10, 15)
i = 15
#for (i in group.sizes) {
  
  prop.data.plot = prop.data[prop.data$groupsize == i,]
  
  
  #plot of MEDIAN proportion of foragers remembered that were the producer
  file.path = paste0("./50percombo/", "group_size_", i, "/plots/median_prop_fss_producer.pdf")
  
  ggplot(prop.data.plot, aes(as.factor(preference), as.factor(attention), fill = med.prop.total)) +
    ggtitle(paste0("Median proportion of foragers remembered that were the producer", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median proportion") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 1)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
  ggsave(file.path, width=13, height=7)
  
  #generally higher median when approachfood is FALSE -- since non-producers will not go directly to food, producer is the most likely to go to food and therefore be the fss most often
  #lower median at memory == 200 and approachfood TRUE -- probably because non-producers feed in the pre-foraging phase and are remembered for most of the model run from then on
  ##FOR WHY THERE ARE THE HIGHEST PROPORTIONS WHEN APPROACHFOOD IS FALSE AND PREFERENCE IS ZERO - non-producers are not feeding as much bc they are not directly attracted to food and they are never following successful foragers (doing so would give them a better chance at feeding and being detected as a successful forager themselves)
  
  
#plot of VARIANCE in proportion of foragers remembered that were the producer
  file.path = paste0("./50percombo/", "group_size_", i, "/plots/variance_prop_fss_producer.pdf")
  
  ggplot(prop.data.plot, aes(as.factor(preference), as.factor(attention), fill = var.prop)) +
    ggtitle(paste0("Variance in proportion of foragers remembered that were the producer", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Variance in proportion") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, max(prop.data.plot$))) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
  ggsave(file.path, width=13, height=7)

#}

  
  ggplot(prop.data.plot, aes(as.factor(preference), as.factor(attention), fill = med.prop.withNAs)) +
    ggtitle(paste0("Median proportion of foragers remembered that were the producer with NAs", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median proportion") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 1)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
  
  
  #plot median for all groups when approach food is false
  file.path = paste0("./50percombo", "/median_prop_fss_producer_appfoodfalse.pdf")
  
  ggplot(prop.data[prop.data$approachfood == "false",], aes(as.factor(preference), as.factor(attention), fill = med.prop)) +
    ggtitle(paste0("Median proportion of foragers remembered that were the producer (approachfood false)", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median proportion") +
    facet_grid(rows=vars(groupsize), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 1)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
  ggsave(file.path, width=13, height=7)
  
  
  #plot median for all groups when approach food is true
  file.path = paste0("./50percombo", "/median_prop_fss_producer_appfoodtrue.pdf")
  
  ggplot(prop.data[prop.data$approachfood == "true",], aes(as.factor(preference), as.factor(attention), fill = med.prop)) +
    ggtitle(paste0("Median proportion of foragers remembered that were the producer (approachfood true)", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median proportion") +
    facet_grid(rows=vars(groupsize), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 1)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))
  
  ggsave(file.path, width=13, height=7)
  
#THINGS TO KNOW
  ##the procedure for setting each agent's first-sf-seen is run at every time step for every agent after the tick has been increased by one
  ##if the agent has no ID saved in its first-sf-seen variable AND a random number is less than the value of attention, then the code checks if there are any agents in the list of successful foragers for that time step
  ##if there is one successful forager that time step, its ID is saved as first-sf-seen
  ##if there is more than one successful forager that time step, one is selected at random to be saved as first-sf-seen
  ##the code for setting a first-sf-seen is never run when attention is zero
  ##agents can set a first-sf-seen even if their memory is zero, but they will not remember it into the next time step

 



```


##For each parameter combo, what is the distribution of ticks in which non-producers formed or changed their first-sf-seen?
```{r}

#make sure fss.data is in the correct order if not already done
fss.data = fss.data[order(fss.data$run, fss.data$ticks), ]

#remove square brackets from the column
fss.data$fsslist = gsub("[[]", "", fss.data$fsslist) 
fss.data$fsslist = gsub("[]]", "", fss.data$fsslist)
  
#starting with fss.data, split the fsslist column into group.size columns 
#do this in a loop, so you don't have to have 20 columns for all the smaller groups
fss.data$change = rep(0, nrow(fss.data))#add a column to keep track of which rows/ticks contain a change

group.sizes = c(3, 6, 10, 15)#, 20)

n.loops = 15 # max(unique(q.data.ord$group.size))
pb = txtProgressBar(min=0, max = n.loops, style=3)
start.time = Sys.time()

for (i in group.sizes) {
  
  loop.data <- fss.data %>%
    filter(groupsize == i) %>%
    mutate(across(starts_with("fss"), ~ str_split_fixed(.x, " ", i)))  # Split fss columns
  
  agents <- seq(0, i - 1)#ids as in netlogo
  
  #loop through each run
  for (j in unique(loop.data$run)) {
    
    loop.data2 <- loop.data %>% filter(run == j)
      
    
    #for each agent column, get the row numbers (and counts for those rows) where the value is: 
      #1. different than the lagged version of the column AND 
      #2. the value in the original version is an agentID (I want to ignore rows where it changes to an NA)
    
    for(k in agents){
      #loop.colname = paste0("fsslist_", as.character(k+1))
      if(k == 0) {next}# skip the producer to only count times when non-producers formed/changed their fss
      
      curr.col = loop.data2[,names(loop.data2) == "fsslist"][,k+1] #this will be the first non-producer column or later
      
      loop.data2 <- loop.data2 %>%
        mutate(change = case_when(
                          !(curr.col == lag(curr.col, 1)) & curr.col %in% agents ~ change + 1,
                          .default = change) 
               )
    }#END OF k LOOP
    
    #save the change column to the original fss.data data frame
    fss.data[fss.data$run == j,]$change = loop.data2$change
    
  }#END OF j LOOP
  
  setTxtProgressBar(pb,i)#update progress bar
  
}#END OF OUTER LOOP
end.time = Sys.time()
run.time = end.time - start.time
run.time # RAN IN 6 HOURS

write_csv(fss.data, "fss_data.csv") #write csv file so I don't have to run the long loop again
```



###THEN, FOR EACH PARAMETER COMBO I CAN GET A SUMMARY OF THE DISTRIBUTION OF TICKS IN WHICH AGENTS CHANGED THEIR FIRST-SF-SEEN AND PLOT THE MEAN/MEDIAN/VARIANCE
```{r}


fss.data = read_csv("fss_data.csv")

#plot a sample histogram
ggplot(fss.data[fss.data$groupsize == 3 &
                fss.data$mem == 50 &
                fss.data$attention == 0.75 &
                fss.data$preference == 0.25 &
                fss.data$approachfood == "true",]) + 
  geom_bar(aes(x=ticks, y=change), stat="identity")

ticks.per.combo = fss.data %>% #count the number of times each tick shows up for each parameter combination
                    group_by(groupsize, 
                             mem, 
                             attention, 
                             preference, 
                             approachfood) %>%
                    summarize(mean.tick = weighted.mean(ticks, change),
                              median.tick = median(rep(ticks, times = change)), #weighted median
                              var.tick = var(rep(ticks, times = change)) #weighted variance
                              )



pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')), space='Lab')

i = 15

file.path = paste0("./50percombo/", "group_size_", i, "/plots/mean_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = mean.tick)) +
    ggtitle(paste0("Mean time step that foragers formed/changed who they remember", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Mean time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 300)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)


file.path = paste0("./50percombo/", "group_size_", i, "/plots/median_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = median.tick)) +
    ggtitle(paste0("Median time step that foragers formed/changed who they remember", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 300)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)


file.path = paste0("./50percombo/", "group_size_", i, "/plots/variance_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = var.tick)) +
    ggtitle(paste0("Variance in time step that foragers formed/changed who they remember", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Variance in time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(min(ticks.per.combo$var.tick), max(ticks.per.combo$var.tick))) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)

```




###Distribution of ticks in which agents changed their first-sf-seen to the producer
```{r}

#make sure fss.data is in the correct order if not already done
fss.data = fss.data[order(fss.data$run, fss.data$ticks), ]

#remove square brackets from the column
fss.data$fsslist = gsub("[[]", "", fss.data$fsslist) 
fss.data$fsslist = gsub("[]]", "", fss.data$fsslist)
  
#starting with fss.data, split the fsslist column into group.size columns 
#do this in a loop, so you don't have to have 20 columns for all the smaller groups
fss.data$change = rep(0, nrow(fss.data))#add a column to keep track of which rows/ticks contain a change

group.sizes = c(3, 6, 10, 15)#, 20)

n.loops = 15 # max(unique(q.data.ord$group.size))
pb = txtProgressBar(min=0, max = n.loops, style=3)
start.time = Sys.time()

for (i in group.sizes) {
  
  loop.data <- fss.data %>%
    filter(groupsize == i) %>%
    mutate(across(starts_with("fss"), ~ str_split_fixed(.x, " ", i)))  # Split fss columns
  
  agents <- seq(0, i - 1)#ids as in netlogo
  
  #loop through each run
  for (j in unique(loop.data$run)) {
    
    loop.data2 <- loop.data %>% filter(run == j)
      
    
    #for each agent column, get the row numbers (and counts for those rows) where the value is: 
      #1. different than the lagged version of the column AND 
      #2. the value in the original version is an agentID (I want to ignore rows where it changes to an NA)
    
    for(k in agents){
      #loop.colname = paste0("fsslist_", as.character(k+1))
      if(k == 0) {next}# skip the producer to only count times when non-producers formed/changed their fss
      
      curr.col = loop.data2[,names(loop.data2) == "fsslist"][,k+1] #this will be the first non-producer column or later
      
      loop.data2 <- loop.data2 %>%
        mutate(change = case_when(
                          !(curr.col == lag(curr.col, 1)) & curr.col %in% 0 ~ change + 1, # only count when the ID in curr.col is the producer's ID
                          .default = change) 
               )
    }#END OF k LOOP
    
    #save the change column to the original fss.data data frame
    fss.data[fss.data$run == j,]$change = loop.data2$change
    
  }#END OF j LOOP
  
  setTxtProgressBar(pb,i)#update progress bar
  
}#END OF OUTER LOOP
end.time = Sys.time()
run.time = end.time - start.time
run.time

write_csv(fss.data, "fss_data_producer.csv") #write csv file so I don't have to run the long loop again

```

```{r}

fss.data = read_csv("fss_data_producer.csv")


ticks.per.combo = fss.data %>% #count the number of times each tick shows up for each parameter combination
                    group_by(groupsize, 
                             mem, 
                             attention, 
                             preference, 
                             approachfood) %>%
                    summarize(mean.tick = weighted.mean(ticks, change),
                              median.tick = median(rep(ticks, times = change)), #weighted median
                              var.tick = var(rep(ticks, times = change)) #weighted variance
                              )



pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')), space='Lab')

i = 3

file.path = paste0("./50percombo/", "group_size_", i, "/plots/prodonly_mean_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = mean.tick)) +
    ggtitle(paste0("Mean time step that foragers remembered producer", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Mean time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 300)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)


file.path = paste0("./50percombo/", "group_size_", i, "/plots/prodonly_median_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = median.tick)) +
    ggtitle(paste0("Median time step that foragers remembered producer", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Median time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(0, 300)) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)


file.path = paste0("./50percombo/", "group_size_", i, "/plots/prodonly_variance_memory_form.pdf")

ggplot(ticks.per.combo[complete.cases(ticks.per.combo) & ticks.per.combo$groupsize == i,], aes(as.factor(preference), as.factor(attention), fill = var.tick)) +
    ggtitle(paste0("Variance in time step that foragers remembered producer", 
                   " group size = ", 
                   i)) +
    labs(y = "Attention", x = "Preference", fill = "Variance in time step") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100), limits=c(min(ticks.per.combo$var.tick), max(ticks.per.combo$var.tick))) + 
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

ggsave(file.path, width=13, height=7)

```





# COMBINE RESULTS INTO A SINGLE DATA FRAME FOR EASIER PLOTTING IN LATER CHUNKS
```{r}

#data frames to hold str differences
full.prox.forXpre = data.frame()
full.prox.postXfor = data.frame()
full.prox.postXpre = data.frame()
full.for.success = data.frame()

#data frames to hold proximity network metrics for each phase
full.prox.metrics.pre = data.frame()
full.prox.metrics.for = data.frame()
full.prox.metrics.post = data.frame()


group.sizes = c(3, 6, 10, 15)
for(i in group.sizes){
  if(i==3){
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_3"
    
  } else if(i==6) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_6"
    
  } else if(i==10) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_10"
    
  } else if(i==15) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_15"
    
  } else if(i==20) {
    file.path = "C:/Users/sanja/Documents/Sanjay's stuff/QuailCentralityABM/R analyses/quail_centrality_4/50percombo/group_size_20"
    
  }
  
  
  #COMBINE DATA FROM DIFFERENT GROUP SIZES INTO ONE DATA FRAME
  file.name = paste(file.path, "prox_forxpre.csv", sep = "/")
  prox.forXpre = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.forXpre = rbind(full.prox.forXpre, prox.forXpre)
  
  
  file.name = paste(file.path, "prox_postxfor.csv", sep = "/")
  prox.postXfor = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.postXfor = rbind(full.prox.postXfor, prox.postXfor)
  

  file.name = paste(file.path, "prox_postxpre.csv", sep = "/")
  prox.postXpre = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.postXpre = rbind(full.prox.postXpre, prox.postXpre)
  
  
  file.name = paste(file.path, "for_success.csv", sep = "/")
  for.success = as.data.frame(read_csv(file.name, col_types = cols()))
  for.success$groupsize = rep(i, nrow(for.success))#add a groupsize column
  full.for.success = rbind(full.for.success, for.success)

  
  file.name = paste(file.path, "prox_metrics_pre.csv", sep = "/")
  prox.metrics.pre = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.metrics.pre = rbind(full.prox.metrics.pre, prox.metrics.pre)
  
  
  file.name = paste(file.path, "prox_metrics_for.csv", sep = "/")
  prox.metrics.for = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.metrics.for = rbind(full.prox.metrics.for, prox.metrics.for)
  
  
  file.name = paste(file.path, "prox_metrics_post.csv", sep = "/")
  prox.metrics.post = as.data.frame(read_csv(file.name, col_types = cols()))
  full.prox.metrics.post = rbind(full.prox.metrics.post, prox.metrics.post)
  
}

#saving a file to send to Liz for her to look into dimension reduction
#full.prox.forXpre = full.prox.forXpre %>% rename(deg.diff = forXpre.deg, str.diff = forXpre.str, memory = mem)
#write_csv(full.prox.forXpre, "prox_phase2vsphase1.csv")

#import proportions of memories that were the producer (it already has data for each group size)
props = read_csv("./50percombo/proportion_fss_producer.csv")

#merge output metrics into a single data frame
full.outputs = full.prox.forXpre %>%
                full_join(full.prox.postXfor, 
                          by = c("run", 
                                 "mem", 
                                 "attention", 
                                 "preference", 
                                 "approachfood", 
                                 "groupsize", 
                                 "combo.num")) %>%
                full_join(full.prox.postXpre, 
                          by = c("run", 
                                 "mem", 
                                 "attention", 
                                 "preference", 
                                 "approachfood", 
                                 "groupsize", 
                                 "combo.num")) %>%
                full_join(full.for.success, 
                          by = c("run", 
                                 "mem", 
                                 "attention", 
                                 "preference", 
                                 "approachfood", 
                                 "groupsize", 
                                 "combo.num")) %>%
                full_join(props, 
                          by = c("run", 
                                 "mem", 
                                 "attention", 
                                 "preference", 
                                 "approachfood", 
                                 "groupsize"))

#data frames with degree and strength per phase only have run column for merging
#first rename deg and str columns to make phase clear
full.prox.metrics.pre = full.prox.metrics.pre %>% rename(pre.deg = A.deg, pre.str = A.str)
full.prox.metrics.for = full.prox.metrics.for %>% rename(for.deg = A.deg, for.str = A.str)
full.prox.metrics.post = full.prox.metrics.post %>% rename(post.deg = A.deg, post.str = A.str)

full.outputs = full.outputs %>%
                full_join(full.prox.metrics.pre, 
                          by = c("run")) %>%
                full_join(full.prox.metrics.for, 
                          by = c("run")) %>%
                full_join(full.prox.metrics.post, 
                          by = c("run")) 



#add columns for scaled strength per phase (just strength/groupsize to see if effects of each parameter are consistent across group sizes)
full.outputs$scld.pre.str = full.outputs$pre.str/(full.outputs$groupsize)#^1.2
full.outputs$scld.for.str = full.outputs$for.str/(full.outputs$groupsize)#^1.2
full.outputs$scld.post.str = full.outputs$post.str/(full.outputs$groupsize)#^1.2

full.outputs$scld.forXpre.str = full.outputs$scld.for.str - full.outputs$scld.pre.str #difference in standardized strengths
full.outputs$scld.postXfor.str = full.outputs$scld.post.str - full.outputs$scld.for.str
full.outputs$scld.postXpre.str = full.outputs$scld.post.str - full.outputs$scld.pre.str

#write_csv(full.outputs, "all_outputs.csv")

```

## Plot one-factor-at-a-time to reveal relationships between each parameter and the output of interest in an easier to understand way (OFAT - see Broeke et al. 2016 in JASSS)
```{r}

full.outputs = read.csv("all_outputs.csv")

# On the y-axis: foraging success of non-producers or difference in strength between A.phase1/2; B.phase2/3; C.phase1/3 
# On the x-axis: attention, preference, memory, approachfood(scrounging), groupsize

#ALL PLOTS HAVE HUGE VARIATION AS PARAMETER VALUES INCREASE - I THINK A SIGN THAT THERE ARE STRONG INTERACTION EFFECTS (LIKELY BC ZERO VALUE FOR ATT/PREF/MEM PREVENT USE OF MOVEMENT RULES COMPLETELY)
#PLOTTING AGAIN WITH ZEROS REMOVED LOOKS SIMILAR STILL
full.outputs.nozeros = full.outputs %>%
                      filter(attention > 0 & 
                             preference > 0 &
                             mem > 0)
  
hist(full.outputs$forXpre.str)
hist(full.outputs.nozeros$forXpre.str)

#Broeke etal. say that each parameter should be plotted while keeping all other parameters at their nominal/default value
#plotting this way... 


full.outputs.att = full.outputs %>% filter(preference == 0.75, 
                                           mem == 100, 
                                           approachfood == FALSE, 
                                           groupsize == 10)
full.outputs.pref = full.outputs %>% filter(attention == 0.75, 
                                           mem == 100, 
                                           approachfood == FALSE, 
                                           groupsize == 10)
full.outputs.mem = full.outputs %>% filter(attention == 0.75, 
                                           preference == 0.75, 
                                           approachfood == FALSE, 
                                           groupsize == 10)
full.outputs.appfood = full.outputs %>% filter(attention == 0.75,
                                               preference == 0.75,
                                               mem == 100, 
                                               groupsize == 10)
full.outputs.grpsize = full.outputs %>% filter(attention == 0.75,
                                               preference == 0.75, 
                                               mem == 100, 
                                               approachfood == FALSE)

#ggplot(full.outputs.att, aes(x = as.factor(attention), y = forXpre.str)) +
#         geom_violin() +
#         stat_summary(fun = median, geom = "point", size = 2, color = "red") +
#         geom_jitter(shape = 1, position = position_jitter(0.05)) 
plot(forXpre.str ~ as.factor(attention), data = full.outputs.att)
plot(forXpre.str ~ as.factor(preference), data = full.outputs.pref)
plot(forXpre.str ~ as.factor(mem), data = full.outputs.mem)
plot(forXpre.str ~ as.factor(approachfood), data = full.outputs.appfood)
plot(forXpre.str ~ as.factor(groupsize), data = full.outputs.grpsize)


plot(postXpre.str ~ as.factor(attention), data = full.outputs.att)
plot(postXpre.str ~ as.factor(preference), data = full.outputs.pref)
plot(postXpre.str ~ as.factor(mem), data = full.outputs.mem)
plot(postXpre.str ~ as.factor(approachfood), data = full.outputs.appfood)
plot(postXpre.str ~ as.factor(groupsize), data = full.outputs.grpsize)


plot(postXfor.str ~ as.factor(attention), data = full.outputs.att)
plot(postXfor.str ~ as.factor(preference), data = full.outputs.pref)
plot(postXfor.str ~ as.factor(mem), data = full.outputs.mem)
plot(postXfor.str ~ as.factor(approachfood), data = full.outputs.appfood)
plot(postXfor.str ~ as.factor(groupsize), data = full.outputs.grpsize)


plot(med.run.energy ~ as.factor(attention), data = full.outputs.att)
plot(med.run.energy ~ as.factor(preference), data = full.outputs.pref)
plot(med.run.energy ~ as.factor(mem), data = full.outputs.mem)
plot(med.run.energy ~ as.factor(approachfood), data = full.outputs.appfood) #strong pattern here
plot(med.run.energy ~ as.factor(groupsize), data = full.outputs.grpsize) #strong pattern here


plot(pre.str ~ as.factor(groupsize), data = full.outputs)
plot(for.str ~ as.factor(groupsize), data = full.outputs)
plot(post.str ~ as.factor(groupsize), data = full.outputs)
plot(forXpre.str ~ as.factor(groupsize), data = full.outputs)
plot(scld.forXpre.str ~ as.factor(groupsize), data = full.outputs)
plot(forXpre.str/(groupsize^1.2) ~ as.factor(groupsize), data = full.outputs)

```



##plot 2 parameters at a time while keeping the others constant
```{r}
library(gridExtra) #need the grid.arrange function

#function to get data summaries for plotting
# data : a data frame
# varname : the name of a column containing the variable to be summarized
# groupnames : vector of column names to be used as grouping variables
data_summary <- function(data, varname, groupnames){
  #require(plyr)
  summary_func <- function(x, col){
    c(mean = mean(x[[col]], na.rm=TRUE),
      median = median(x[[col]], na.rm=TRUE),
      sd = sd(x[[col]], na.rm=TRUE),
      se = sd(x[[col]], na.rm=TRUE)/sqrt(length(x[[col]])), #standard error == sd/sqrt(n)
      lowquant = quantile(x[[col]], na.rm=TRUE)[["25%"]],
      highquant = quantile(x[[col]], na.rm=TRUE)[["75%"]]
      )
  }
  data_sum<-plyr::ddply(data, 
                        groupnames, 
                        .fun=summary_func,
                        varname)
  
  data_sum <- plyr::rename(data_sum, c("mean" = varname))
  
 return(data_sum)
}


# how do effects of att/pref/mem change across group sizes 
p = list() #list to hold plots inspecting interactions between each cognitive skill and groupsize/approachfood
p2 = list() #list to hold plots inspecting interactions between each att/pref and memory/approachfood

params = c("attention", "preference", "mem")
outputs = c("scld.forXpre.str", "props.for", "scld.postXfor.str", "scld.postXpre.str", "props.post", "med.run.energy") #probably also want plots for proportion of times producer was remembered as fss

for(i in 1:length(outputs)) {
  
  yaxis = outputs[i]
  p[[i]] = list() #each item in p will be a list and each item in that list will be the plot for att/pref/mem
  p2[[i]] = list()
  
  for(j in 1:length(params)) {
    
    xaxis = params[j]
    
    if(xaxis == "attention") {
      dat = full.outputs %>% # data keeping preference and memory constant
              filter(preference == 1,
                     mem == 100) %>%
              data_summary(varname = yaxis, 
                          groupnames = c(xaxis, "groupsize", "approachfood"))
      
      dat2 = full.outputs %>% 
              filter(preference == 1,
                     groupsize == 15) %>% #going with groupsize 15 because it shows the clearest patterns 
              data_summary(varname = yaxis, 
                          groupnames = c(xaxis, "mem", "approachfood"))
      
    } else if(xaxis == "preference") {
      dat = full.outputs %>% # data keeping attention and memory constant
              filter(attention == 1,
                     mem == 100) %>%
              data_summary(varname = yaxis, 
                          groupnames = c(xaxis, "groupsize", "approachfood"))
      
      dat2 = full.outputs %>% 
              filter(attention == 1,
                     groupsize == 15) %>% #going with groupsize 15 because it shows the clearest patterns
              data_summary(varname = yaxis, 
                          groupnames = c(xaxis, "mem", "approachfood"))
      
    } else if(xaxis == "mem") {
      dat = full.outputs %>% # data keeping preference and attention constant
              filter(attention == 1,
                     preference == 1) %>%
              data_summary(varname = yaxis, 
                          groupnames = c(xaxis, "groupsize", "approachfood"))
    }
    
    
    #dat$groupsize = as.factor(dat$groupsize)
    
    p[[i]][[j]] = ggplot(dat, aes(x=.data[[xaxis]], y=median, group=groupsize, color=groupsize)) + 
                  geom_line() +
                  geom_point()+
                  facet_grid(cols = vars(approachfood))+
                  geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", xaxis, " on median ", yaxis), 
                       x = xaxis, 
                       y = yaxis)+
                  theme_classic() +
                  scale_color_gradientn(colors =  colorRampPalette(brewer.pal(9, "Oranges"))(100)[15:100],
                                        breaks = c(3, 6, 10, 15))
    
    #dat2$mem = as.factor(dat2$mem)
    
    p2[[i]][[j]] = ggplot(dat2, aes(x=.data[[xaxis]], y=median, group=mem, color=mem)) + 
                  geom_line() +
                  geom_point()+
                  facet_grid(cols = vars(approachfood))+
                  geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", xaxis, " on median ", yaxis), 
                       x = xaxis, 
                       y = yaxis)+
                  theme_classic() +
                  scale_color_gradientn(colors =  colorRampPalette(brewer.pal(9, "Oranges"))(100)[15:100])
    
  }
}

#save p plots to a single pdf
pdf("parameters_by_grpsize_and_appfood.pdf", onefile = TRUE)
for(i in seq(length(p))) {
  do.call("grid.arrange", p[[i]])
}
dev.off()


#save p2 plots to a single pdf
pdf("parameters_by_memory_and_appfood.pdf", onefile = TRUE)
for(i in seq(length(p2))) {
  do.call("grid.arrange", p2[[i]])
}
dev.off()


# plot outputs against each other
##change in prod strength by props.for
full.outputs %>% 
              filter(attention == 1,
                     preference == 1,
                     groupsize == 15) %>%
              data_summary(varname = "forXpre.str", 
                          groupnames = c("props.for", "mem", "approachfood")) %>%
              ggplot( aes(x=props.for, y=median, group=as.factor(mem), color=as.factor(mem))) + 
                  #geom_line() +
                  geom_point()+
                  facet_grid(cols = vars(approachfood))+
                  #geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", "props.for", " on median ", "forXpre.str"), 
                       x = "props.for", 
                       y = "forXpre.str")+
                  theme_classic()

##change in prod strength by med.run.energy
full.outputs %>% 
              filter(attention == 1,
                     mem == 100,
                     groupsize == 15) %>%
              data_summary(varname = "forXpre.str", 
                          groupnames = c("med.run.energy", "preference", "approachfood")) %>%
              ggplot( aes(x=median, y=med.run.energy, group=as.factor(preference), color=as.factor(preference))) + 
                  #geom_line() +
                  geom_point()+
                  facet_grid(cols = vars(approachfood))+
                  #geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", "forXpre.str", " on ", "med.run.energy"), 
                       x = "forXpre.str", 
                       y = "med.run.energy")+
                  theme_classic()



#groupsize relation to change in producer's strength
full.outputs %>%
              data_summary(varname = "forXpre.str", 
                          groupnames = c("groupsize")) %>%
              ggplot( aes(x=groupsize, y=median)) + 
                  geom_line() +
                  geom_point()+
                  geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", "groupsize", " on median ", "forXpre.str"), 
                       x = "groupsize", 
                       y = "forXpre.str")+
                  theme_classic()

#groupsize relation to change in producer strength (scaled by group size)
full.outputs %>%
              data_summary(varname = "scld.forXpre.str", 
                          groupnames = c("groupsize")) %>%
              ggplot( aes(x=groupsize, y=median)) + 
                  geom_line() +
                  geom_point()+
                  geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", "groupsize", " on median ", "scaled forXpre.str"), 
                       x = "groupsize", 
                       y = "scaled forXpre.str")+
                  theme_classic()

#groupsize relation to sqrt change in producer strength (scaled by group size)
full.outputs %>%
              mutate(log.forXpre.str = log(forXpre.str)) %>%
              data_summary(varname = "log.forXpre.str", 
                          groupnames = c("groupsize")) %>%
              ggplot( aes(x=groupsize, y=median)) + 
                  geom_line() +
                  geom_point()+
                  geom_errorbar(aes(ymin=lowquant, ymax=highquant), width=.05) +
                  labs(title=paste0("Effect of ", "groupsize", " on median ", "log forXpre.str"), 
                       x = "groupsize", 
                       y = "log forXpre.str")+
                  theme_classic()

```




## heat maps with overlayed values
```{r}
pal <- colorRampPalette(rev(brewer.pal(11, 'Spectral')), space='Lab')



#finding medians of metrics for each parameter combo:
full.outputs.combo = full.outputs %>% 
                      group_by(groupsize,
                               mem, 
                               attention, 
                               preference, 
                               approachfood, 
                               combo.num) %>% 
                      summarize(n=n(),
                                med.forXpre.str = median(scld.forXpre.str), #median difference in scaled prod str phase2v1
                                med.postXfor.str = median(scld.postXfor.str),#median difference in scaled prod str phase3v2
                                med.postXpre.str = median(scld.postXpre.str),#median difference in scaled prod str phase3v1
                                med.ntimesteps = median(n.timesteps),#median num timesteps non-prods ate
                                med.combo.energy = median(med.run.energy),#median energy of non-prods
                                med.props.total = median(props.total),#median proportion of memories == prod
                                med.props.pre = median(props.pre),#median proportion of phase1 memories == prod
                                med.props.for = median(props.for),#median proportion of phase2 memories == prod
                                med.props.post = median(props.post),#median proportion of phase3 mems == prod
                                )

p.strdifs1 = list()
p.strdifs2 = list()
p.forsuccess = list()
p.propsprepost = list()

group.sizes = c(3,6,10,15)
strdifs1 = c("med.forXpre.str", "med.props.for") 
strdifs2= c("med.postXfor.str", "med.postXpre.str")
forsuccess = c("med.ntimesteps", "med.combo.energy")
propsprepost = c("med.props.post", "med.props.total") 

for(i in 1:length(group.sizes)) {
  
  gsize = group.sizes[i]
  
  p.strdifs1[[i]] = list()
  p.strdifs2[[i]] = list()
  p.forsuccess[[i]] = list()
  p.propsprepost[[i]] = list()
  
  for(j in 1:length(strdifs1)) {
    
    yvar = strdifs1[j]
    
    p.strdifs1[[i]][[j]] = full.outputs.combo %>%
                            filter(groupsize == gsize) %>%
                              ggplot(aes(as.factor(preference), as.factor(attention), fill = .data[[yvar]])) +
                              ggtitle(paste(yvar, "group size:", gsize, sep = " ")) +
                              labs(y = "Attention", x = "Preference", fill = yvar) +
                              facet_grid(rows=vars(approachfood), cols=vars(mem)) +
                              geom_tile() +
                              scale_fill_gradientn(colours = pal(100)) +
                              theme_minimal() +
                              theme(aspect.ratio=1, text=element_text(size=15))
  }
  
  
  for(k in 1:length(strdifs2)) {
    
    yvar = strdifs2[k]
    
    p.strdifs2[[i]][[k]] = full.outputs.combo %>%
                            filter(groupsize == gsize) %>%
                              ggplot(aes(as.factor(preference), as.factor(attention), fill = .data[[yvar]])) +
                              ggtitle(paste(yvar, "group size:", gsize, sep = " ")) +
                              labs(y = "Attention", x = "Preference", fill = yvar) +
                              facet_grid(rows=vars(approachfood), cols=vars(mem)) +
                              geom_tile() +
                              scale_fill_gradientn(colours = pal(100)) +
                              theme_minimal() +
                              theme(aspect.ratio=1, text=element_text(size=15))
  }
  
  
  for(l in 1:length(forsuccess)) {
    
    yvar = forsuccess[l]
    
    p.forsuccess[[i]][[l]] = full.outputs.combo %>%
                            filter(groupsize == gsize) %>%
                              ggplot(aes(as.factor(preference), as.factor(attention), fill = .data[[yvar]])) +
                              ggtitle(paste(yvar, "group size:", gsize, sep = " ")) +
                              labs(y = "Attention", x = "Preference", fill = yvar) +
                              facet_grid(rows=vars(approachfood), cols=vars(mem)) +
                              geom_tile() +
                              scale_fill_gradientn(colours = pal(100)) +
                              theme_minimal() +
                              theme(aspect.ratio=1, text=element_text(size=15))
  }
  
  
  for(m in 1:length(propsprepost)) {
    
    yvar = propsprepost[m]
    
    p.propsprepost[[i]][[m]] = full.outputs.combo %>%
                            filter(groupsize == gsize) %>%
                              ggplot(aes(as.factor(preference), as.factor(attention), fill = .data[[yvar]])) +
                              ggtitle(paste(yvar, "group size:", gsize, sep = " ")) +
                              labs(y = "Attention", x = "Preference", fill = yvar) +
                              facet_grid(rows=vars(approachfood), cols=vars(mem)) +
                              geom_tile() +
                              scale_fill_gradientn(colours = pal(100)) +
                              theme_minimal() +
                              theme(aspect.ratio=1, text=element_text(size=15))
  }
  
  
}



#save p.strdifs1 plots to a single pdf
pdf("forXpre_str_heatmaps.pdf", onefile = TRUE)
for(i in seq(length(p.strdifs1))) {
  do.call("grid.arrange", p.strdifs1[[i]])
}
dev.off()

#save p.strdifs2 plots to a single pdf
pdf("postX_str_heatmaps.pdf", onefile = TRUE)
for(i in seq(length(p.strdifs2))) {
  do.call("grid.arrange", p.strdifs2[[i]])
}
dev.off()

#save p.forsuccess plots to a single pdf
pdf("foraging_success_heatmaps.pdf", onefile = TRUE)
for(i in seq(length(p.forsuccess))) {
  do.call("grid.arrange", p.forsuccess[[i]])
}
dev.off()

#save p.propsprepost plots to a single pdf
pdf("props_heatmaps.pdf", onefile = TRUE)
for(i in seq(length(p.propsprepost))) {
  do.call("grid.arrange", p.propsprepost[[i]])
}
dev.off()


#plot of median difference in producer strength between foraging and pre-foraging phases with numbers overlapping
full.outputs.combo %>% 
  filter(groupsize == gsize) %>%
  ggplot(aes(as.factor(preference), as.factor(attention), fill = med.forXpre.str)) +
    ggtitle(paste("Difference in producer's proximity strength between foraging and pre-foraging phases", 
            "group size:", gsize, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median Difference in Strength") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100)) +
    geom_text(aes(label = round(med.props.for, 1))) + #argument to add values on top of heat map
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))


#plot of median energy of non-producers with dif in strength values overlapping
full.outputs.combo %>% 
  filter(groupsize == gsize) %>%
  ggplot(aes(as.factor(preference), as.factor(attention), fill = med.combo.energy)) +
    ggtitle(paste("Median energy of agents", 
            "group size:", gsize, sep = " ")) +
    labs(y = "Attention", x = "Preference", fill = "Median energy") +
    facet_grid(rows=vars(approachfood), cols=vars(mem)) +
    geom_tile() +
    scale_fill_gradientn(colours = pal(100)) +
    geom_text(aes(label = round(med.forXpre.str))) + #argument to add values on top of heat map
    theme_minimal() +
    theme(aspect.ratio=1, text=element_text(size=15))

```


#Run GLMs to better understand relationships between parameters and change in proximity strength/foraging success
# SCRAP THIS - LMS ARE NOT APPROPRIATE AND THEY WERE NOT FITTING WELL ANYWAY
```{r}


mod.forXpre = lm(forXpre.str ~ attention + 
                              preference + 
                              mem +
                              approachfood + 
                              groupsize + 
                              mem:attention + #bc of how I built the model, memory should have an effect through attention/preference 
                              mem:preference +
                              groupsize:attention + #groupsize influences possible strength since there are more/less agents to be in proximity with inside the arena that doesn't change size, so other predictors expected to have a larger effect for larger group sizes
                              groupsize:preference +
                              groupsize:mem +
                              groupsize:approachfood, 
              data = full.outputs.nozeros)
plot(mod.forXpre) # very heteroscedastic when including zeros for att/pref/mem or not (before adding groupsize interaction terms)


#COMPARE COEFFICIENTS CALCULATED BY mod.forXpre TO A WEIGHTED LEAST SQUARES MODEL
weights.forXpre = 1 / lm(abs(mod.forXpre$residuals) ~ mod.forXpre$fitted.values)$fitted.values^2
weighted.mod.forXpre = lm(forXpre.str ~ attention + 
                              preference + 
                              mem + 
                              approachfood + 
                              groupsize + 
                              mem:attention + 
                              mem:preference, 
                          weights = weights.forXpre,
                          data = full.outputs)
plot(weighted.mod.forXpre)#still has issues
summary(weighted.mod.forXpre)

#try robust std errors using sandwich estimator
library(sandwich)
lmtest::coeftest(mod.forXpre, vcov = sandwich)

#try the model for one group size at a time
mod.forXpre15 = lm(forXpre.str ~ attention + 
                              preference + 
                              mem + 
                              approachfood + 
                              mem:attention + 
                              mem:preference, 
              data = full.outputs[full.outputs$groupsize==15,])
plot(mod.forXpre15)#only a bit better
summary(mod.forXpre15)$coef



mod.postXfor = lm(postXfor.str ~ attention + 
                              preference + 
                              mem + 
                              approachfood + 
                              groupsize + 
                              mem:attention + 
                              mem:preference, 
              data = full.outputs)
plot(mod.postXfor) # also very heteroscedastic and non-normal


mod.forsuccess = lm(med.run.energy ~ attention + 
                              preference + 
                              mem + 
                              approachfood + 
                              groupsize + 
                              mem:attention + 
                              mem:preference, 
              data = full.outputs)
plot(mod.postXfor) # also very heteroscedastic and non-normal




```





